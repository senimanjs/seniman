import { FastRateLimit } from 'fast-ratelimit';
import { nanoid } from 'nanoid';
import { Window } from './window.js';
import { CrawlerRenderer } from './crawler/index.js';

// _htmlBuffers.js is generated by scripts/build.js
import htmlBuffers from "./_htmlBuffers.js";

import {
  RATELIMIT_WINDOW_INPUT_THRESHOLD,
  RATELIMIT_WINDOW_INPUT_TTL_SECONDS,
  RATELIMIT_WINDOW_CREATION_THRESHOLD,
  RATELIMIT_WINDOW_CREATION_TTL_SECONDS,
  ENABLE_CRAWLER_RENDERER,
  MAX_INPUT_EVENT_BUFFER_SIZE
} from './config.js';
import { enqueueWindowInput, getWindow, registerWindow, deregisterWindow } from './state.js';

export function createRoot(rootFn) {
  return new Root(rootFn);
}

class Root {

  constructor(rootFn) {
    this.rootFn = rootFn;

    this.externalWindowIdMapping = new Map();

    this.crawlerRenderingEnabled = ENABLE_CRAWLER_RENDERER;
    this.crawlerRenderer = ENABLE_CRAWLER_RENDERER ? new CrawlerRenderer() : null;

    // TODO: we'll want to make this configurable & broadcast
    // this to the client so that they can adjust their message
    // sending rate accordingly -- i.e. we'll catch mostly the bad actors
    // here and not good actors sending too many messages in some chatty part
    // of the app
    this.messageLimiter = new FastRateLimit({
      threshold: RATELIMIT_WINDOW_INPUT_THRESHOLD,
      ttl: RATELIMIT_WINDOW_INPUT_TTL_SECONDS
    });

    this.windowCreationLimiter = new FastRateLimit({
      threshold: RATELIMIT_WINDOW_CREATION_THRESHOLD,
      ttl: RATELIMIT_WINDOW_CREATION_TTL_SECONDS
    });

    this.droppedMessagesCount = 0;

    /*
    setInterval(() => {
      if (this.droppedMessagesCount > 0) {
        console.log('Dropped messages: ' + this.droppedMessagesCount);
        this.droppedMessagesCount = 0;
      }
    }, 2000);
    */

    this.disableHtmlCompression = false;
  }

  hasWindow(windowId) {
    return getWindow(windowId) != null;
  }

  setRateLimit({ disabled }) {
    if (disabled) {
      // assign no-op rate limiters 
      this.messageLimiter = {
        consumeSync: () => true
      };

      this.windowCreationLimiter = {
        consumeSync: () => true
      };
    }
  }

  setDisableHtmlCompression() {
    this.disableHtmlCompression = true;
  }

  _enqueueMessage(windowId, message) {

    // apply global limit
    // TODO: move the length check to the websocket server's max message size
    // do this once we set up client-side rate limiting
    let isUnderLimit =
      this.messageLimiter.consumeSync(windowId) &&
      message.byteLength < MAX_INPUT_EVENT_BUFFER_SIZE;

    // TODO: print on a regular interval the amount of messages that are being dropped
    if (!isUnderLimit) {
      this.droppedMessagesCount++;
      return;
    }

    // TODO: apply window & handler specific limits

    let inputBuffer = Buffer.from(message);
    let txPortId = inputBuffer.readUInt16LE(0);

    // portId of 0 is reserved for the pong command
    if (txPortId == 0) {
      let window = getWindow(windowId);

      if (window) {
        window.registerPong(inputBuffer);
      }
      return;
    }

    enqueueWindowInput(windowId, inputBuffer);
  }

  applyNewConnection(ws, { url, headers, ipAddress }, auxContext) {

    let params = new URLSearchParams(url.split('?')[1]);

    // then, get the values from the params object
    let externalWindowId = params.get('wi') || '';
    let readOffset = parseInt(params.get('ro'));
    let viewportSize = params.get('vs').split('x').map((num) => parseInt(num));
    let locationString = params.get('lo');

    let isUnderRateLimit = this.windowCreationLimiter.consumeSync(ipAddress);

    if (!isUnderRateLimit) {
      // 3010 is code for "excessive window creation" -- the client will close and not reconnect.
      ws.close(3010);
      return;
    }

    let cookieString = headers.get('cookie') || '';

    // href is the combination of:
    // - the protocol+hostname+port (take it from the Origin header for security)
    // - pathname
    // - searchParams
    let origin = headers.get('origin') || '';
    let href = origin + locationString;

    let pageParams = {
      windowId: null,
      href,
      viewportSize,
      readOffset,
      cookieString,
    };

    if (externalWindowId) {
      pageParams.windowId = externalWindowId;

      let windowId = this._convertExternalWindowIdToInternal(externalWindowId);

      if (this.hasWindow(windowId)) {
        this.reconnectWindow(ws, pageParams);
      } else {
        // 3001 is the code for "no such window" -- the client will reload and re-initialize for a new window
        ws.close(3001);
        return;
      }
    } else {
      let externalWindowId = nanoid();
      pageParams.windowId = externalWindowId;
      this.initWindow(ws, pageParams, auxContext);
    }
  }

  initWindow(ws, pageParams, auxContext) {

    // TODO: pass request's ip address here, and rate limit window creation based on ip address
    let window = new Window(this, pageParams, auxContext, this.rootFn, buf => {
      ws.send(buf);
    });

    this.externalWindowIdMapping.set(pageParams.windowId, window.id);

    registerWindow(window);

    window.start();

    window.onDestroy(() => {
      this.externalWindowIdMapping.delete(pageParams.windowId);
      deregisterWindow(window);
      ws.close();
    });

    window.startPingLoop(false);

    this._setupWsListeners(ws, window.id);
  }

  async getHtmlResponse({ url, headers, ipAddress, isSecure }) {
    let isUnderRateLimit = this.windowCreationLimiter.consumeSync(ipAddress);

    if (!isUnderRateLimit) {
      return {
        statusCode: 429,
        headers: {
          'Content-Type': 'text/plain',
          'Cache-Control': 'no-store',
        },
        body: 'Too many requests'
      }
    }

    let responseHeaders = {
      'Content-Type': 'text/html',
      'Vary': 'Accept',
      'Cache-Control': 'no-store',
    };

    if (this.crawlerRenderingEnabled && this.crawlerRenderer.shouldUseRenderer(headers)) {

      // href is combination of:
      // - the protocol+hostname+port 
      // - pathname
      // - searchParams

      // in cloudflare workers Service Worker mode, the url might contain the host
      // let's pick it out for now
      // TODO: clean up the flow
      if (!(url.startsWith('https://') || url.startsWith('http://'))) {
        url = (isSecure ? 'https://' : 'http://') + headers.get('host') + url;
      }

      let href = url;

      // TODO: check if we have a cached response for this request
      let html = await this.renderHtml({ headers, href });
      responseHeaders['Content-Length'] = Buffer.byteLength(html);

      return {
        statusCode: 200,
        headers: responseHeaders,
        body: html
      };
    }

    let acceptEncoding = headers.get('accept-encoding') || '';
    let algo;
    let html;

    // in cloudflare workers, we need to be sending uncompressed HTML
    // seemingly CF doesn't support pre-compressed HTML
    if (this.disableHtmlCompression) {
      html = htmlBuffers.uncompressed;
    } else {
      if (acceptEncoding.indexOf('br') > -1) {
        algo = 'br';
        html = htmlBuffers.br;
      } else if (acceptEncoding.indexOf('gzip') > -1) {
        algo = 'gzip';
        html = htmlBuffers.gzip;
      } else {
        html = htmlBuffers.uncompressed;
      }
    }

    responseHeaders['Content-Length'] = html.byteLength;

    if (algo) {
      responseHeaders['Content-Encoding'] = algo;
    }

    return {
      statusCode: 200,
      headers: responseHeaders,
      body: html
    };
  }

  async renderHtml({ headers, href }) {
    let cookieString = headers.get('cookie') || '';

    let pageParams = {
      windowId: nanoid(),
      href,

      // TODO: get viewport size from request
      viewportSize: [1920, 1080],

      readOffset: 0,
      cookieString
    };

    let htmlRenderContext = this.crawlerRenderer.createHtmlRenderingContext();

    let window = new Window(this, pageParams, auxContext, this.rootFn, buf => {
      htmlRenderContext.feedBuffer(buf);
    });

    registerWindow(window);

    window.start();

    window.onDestroy(() => {
      deregisterWindow(window);
    });

    return new Promise((resolve, reject) => {
      htmlRenderContext.onRenderComplete((html) => {
        // only CF worker requires this for some timing reason -- this is a quick fix
        // TODO: clean this up (hint: ExecWorkStartTimeout isn't being cleared in one of the last _scheduleExecWork's)
        setTimeout(() => {
          window.destroy();
        }, 100);

        resolve(html);
      });

      htmlRenderContext.onRenderError((err) => {
        window.destroy();
        reject(err);
      });
    });
  }

  _convertExternalWindowIdToInternal(externalWindowId) {
    return this.externalWindowIdMapping.get(externalWindowId);
  }

  reconnectWindow(ws, pageParams) {
    let windowId = this._convertExternalWindowIdToInternal(pageParams.windowId);

    let window = getWindow(windowId);

    // update the window's buffer push function to refer to the new websocket
    window.onBuffer(buf => ws.send(buf));

    this._setupWsListeners(ws, windowId);

    window.startPingLoop(true);
    window.reconnect(pageParams);
  }

  _setupWsListeners(ws, windowId) {
    ws.on('message', async (message) => {
      this._enqueueMessage(windowId, message);
    });

    ws.on('close', () => {
      this.disconnectWindow(windowId);
    });
  }

  disconnectWindow(windowId) {

    let window = getWindow(windowId);

    if (window) {
      window.disconnect();
    }
  }
}